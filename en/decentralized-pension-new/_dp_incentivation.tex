\subsection{Incentivierung}

Da das System nicht von einer Firma oder Regierung zur Verfügung gestellt wird sondern von der Community dezentralisiert betrieben wird ist es wichtig, dass es Anreize das System so fair wie möglich funktionieren.

Uns war bewusst, dass es nicht möglich sein wird ein System zu Schaffen in dem es nur Gewinner gibt.

Unserer wichtigsten Ziele.

- DAO
- Fair



\begin{itemize}
\item Beitragsjahre => Bezugsjahre
\item Beitragshöhe => Beitragsauszahlung
\item Early Adopter Bonus
\item Bonus für letzte Teilnehmer im System
\end{itemize}


\newpage

\subsection{Pension pre calculation}

\subsubsection*{Settings}

We need some fixed and initial settings,
one of them is 

\begin{equation*}
	min = 0.0000000000000001
\end{equation*}

\begin{equation*}
	years = 40
\end{equation*}

\subsubsection*{entitlementMonths}

\begin{equation*}
	entitlementMonths = \frac{payedMonths^2}{12 \cdot years}
\end{equation*}

\subsubsection*{CCV - Current contribution value}

\begin{equation*}
CCV = \begin{cases} 
CCV * 110\% & _{(unit+10\% > CCV)} \\
CCV * 90\% & _{(unit-10\% < CCV)} \\
CCV & _{(other)}
\end{cases}
\end{equation*}

\subsubsection*{DPT}

\begin{equation*}
DPT = DPT_{base} \cdot DPT_{bonus}
\end{equation*}

\begin{equation*}
DPT_{base} = \begin{cases} 
1 + \frac{unit-max(units)} {CCV - max(units)} 
  & _{(unit > CCV)} \\
\frac{unit - min} {CCV - min} 
  & _{(unit < CCV)} \\
1.0 & _{(other)}
\end{cases}
\end{equation*}

\begin{equation*}
DPT_{bonus} = \begin{cases} 
1.0 + (\frac{(years - year + 1.0)^2}
      {years^2} \cdot 0.5) & _{(year < years)} \\
1.0 & _{(other)} 
\end{cases}
\end{equation*}


\newpage

\subsection{Pension post calculation}

Baisic pension calculation is your points
as factor for contribution pension rate and 
your points as factor for savings pension rate.

\begin{equation*}
pension = DPT \cdot CPR + DPT \cdot SPR + DPT \cdot LPR
\end{equation*}

Die Rente baut auf drei verschiedene Töpfe auf, die Monatlichen Beiträge,
die Gespeicherten Beiträge und die Nachzüglicher Beiträge.

Alle diese Töpfe werden unterschiedlich befüllt.
Die Monatlichen Beiträge werden nur als Durchschnitts Beitrag an die Berechtigten  per Umlageverfahren umverteilt und der Rest wird im Savings hinterlegt.
Bei den Nachzüglern ist die Idee, dass die letzte Generation die das System verlassen würde einen Bonus erhalten würde, dieser Topf wird befüllt,
solange kein Monatsanspruch bei dem Benutzer besteht.

\subsubsection*{Pension from contributions}

\begin{equation*}
	total\_units\_month = 
	\sum_{n=1}^{count} units
\end{equation*}

\begin{equation*}
	total\_weighted\_dpt = 
	\sum_{n=1}^{count} pension\_user\_dpt
\end{equation*}

\begin{equation*}
	weighted\_dpt\_units\_rate = 	
	\frac{total\_units\_month  \cdot avg(units)} 
	{total\_weighted\_dpt}		
\end{equation*}

If $weighted\_dpt\_units\_rate > avg(units)$ then $weighted\_dpt\_units\_rate = avg(units)$
        

\begin{equation*}
	pension = 	
	weighted\_dpt\_units\_rate \cdot user\_dpt
\end{equation*}


\subsubsection*{Pension from saving}

Wenn $weighted\_dpt\_units\_rate < avg(units)$ dann 

\begin{equation*}
	active\_user\_dpts = 
	\sum_{n=1}^{count} active\_user\_dpt
\end{equation*}

\begin{equation*}
	total\_units = 	
	\sum_{p=1}^{periods} \sum_{n=1}^{users} user\_units	
\end{equation*}

\begin{equation*}
	savings\_dpt\_units\_rate = 	
	\frac{total\_units} 
	{active\_user\_dpts \cdot years \cdot 12}		
\end{equation*}

\begin{equation*}
	pension = savings\_dpt\_units\_rate \cdot user\_dpt
\end{equation*}


\subsubsection*{Pension from laggards funds}

Wenn $entitlementMonths >= 1$ dann 

\begin{equation*}
	active\_user\_dpts = 
	\sum_{n=1}^{count} active\_user\_dpt
\end{equation*}

\begin{equation*}
	total\_units = 	
	\sum_{p=1}^{periods} \sum_{n=1}^{users} user\_units	
\end{equation*}

\begin{equation*}
	laggards\_dpt\_units\_rate = 	
	\frac{total\_units} 
	{active\_user\_dpts \cdot years \cdot 12}		
\end{equation*}

\begin{equation*}
	pension = laggards\_dpt\_units\_rate \cdot user\_dpt
\end{equation*}


Voraussetzung ist gegeben wenn $pensioners / periods_open$ genau 1 entspricht